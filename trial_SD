#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <UniversalTelegramBot.h>
#include <ArduinoJson.h>
#include <Adafruit_Sensor.h>
#include <DHT.h>
#include <DHT_U.h>

#include <SPI.h>
#include <SD.h>
#include <time.h>

// --- WLAN & Telegram ---
#define WIFI_SSID     "Ragnarok"
#define WIFI_PASS     "CT-5555Fives"
#define BOTtoken      "8548226615:AAE9JTFvFRG2RZHcNEGMl0QrYyyJjBanr_A"
#define CHAT_ID       "74517358"

WiFiClientSecure client;
UniversalTelegramBot bot(BOTtoken, client);

// --- DHT22 ---
#define DHTPIN  D2
#define DHTPIN2 D3
#define DHTTYPE DHT22
DHT dht(DHTPIN, DHTTYPE);
DHT dht2(DHTPIN2, DHTTYPE);

// --- Lüfter via MOSFET ---
#define FAN_PIN D12

// --- SD / SPI Pins ---
// Hinweis: SCK und MOSI dürfen NICHT identisch sein.
#define SPI_MISO_PIN D6
#define SPI_MOSI_PIN D7
#define SPI_SCK_PIN  D7   // falls falsch: ändern!
#define SD_CS_PIN    D5   // ggf. an deine Verdrahtung anpassen

// --- Logging ---
static const char* LOG_PATH = "/measurements.tsv";
const unsigned long LOG_INTERVAL_MS = 5000UL;
unsigned long lastLog = 0;

// --- Zeitsteuerung ---
unsigned long lastStatusSend = 0;
unsigned long lastFanCycle = 0;
bool fanOn = false;

// --- Phasenstatus ---
int phase = 1;

// --- 24 Stunden in Millisekunden ---
const unsigned long DAY_MS = 24UL * 60UL * 60UL * 1000UL;

// --- Intervalle (bestehendes Zeug) ---
const unsigned long STATUS_INTERVAL = DAY_MS;
const unsigned long FAN_ON_DURATION = 3000UL;
const unsigned long FAN_CYCLE_INTERVAL = DAY_MS;

// --- Utility ---
#define COUNT_OF(x) (sizeof(x)/sizeof((x)[0]))
const char* pickRandom(const char* const* arr, size_t n) {
  if (n == 0) return "";
  long idx = random(0, (long)n);
  return arr[idx];
}

// -------------------- WiFi --------------------
void connectWiFi() {
  Serial.print("Verbindung zu WiFi: ");
  Serial.println(WIFI_SSID);
  WiFi.begin(WIFI_SSID, WIFI_PASS);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\nVerbunden. IP-Adresse: " + WiFi.localIP().toString());
  client.setInsecure();  // Telegram TLS ohne Zertifikat
}

// -------------------- Zeit / NTP (Copenhagen) --------------------
void initTime() {
  setenv("TZ", "CET-1CEST,M3.5.0/02,M10.5.0/03", 1);
  tzset();
  configTime(0, 0, "pool.ntp.org", "time.nist.gov", "europe.pool.ntp.org");

  struct tm timeinfo;
  int tries = 0;
  while (!getLocalTime(&timeinfo) && tries < 20) {
    delay(250);
    tries++;
  }
  if (tries >= 20) {
    Serial.println("Warnung: NTP Zeit noch nicht verfuegbar (kommt evtl. spaeter).");
  } else {
    Serial.println("Zeit via NTP synchronisiert.");
  }
}

String isoTimeNow() {
  struct tm timeinfo;
  if (!getLocalTime(&timeinfo)) {
    return String("1970-01-01T00:00:00");
  }
  char buf[32];
  strftime(buf, sizeof(buf), "%Y-%m-%dT%H:%M:%S", &timeinfo);
  return String(buf);
}

uint64_t epochMsNow() {
  time_t nowSec = time(nullptr);
  if (nowSec < 100000) return 0;
  return (uint64_t)nowSec * 1000ULL;
}

// -------------------- SD --------------------
bool initSD() {
  Serial.println("Initialisiere SD…");
  SPI.begin(SPI_SCK_PIN, SPI_MISO_PIN, SPI_MOSI_PIN, SD_CS_PIN);

  if (!SD.begin(SD_CS_PIN)) {
    Serial.println("SD.begin fehlgeschlagen.");
    return false;
  }
  Serial.println("SD.begin OK.");

  bool writeHeader = false;
  if (!SD.exists(LOG_PATH)) {
    writeHeader = true;
  } else {
    File f = SD.open(LOG_PATH, FILE_READ);
    if (!f) {
      writeHeader = true;
    } else {
      if (f.size() == 0) writeHeader = true;
      f.close();
    }
  }

  if (writeHeader) {
    File f = SD.open(LOG_PATH, FILE_WRITE);
    if (!f) {
      Serial.println("Konnte Log-Datei nicht erstellen.");
      return false;
    }
    f.println("iso_time\tepoch_ms\tt1_c\th1_pct\tt2_c\th2_pct");
    f.close();
    Serial.println("Header geschrieben.");
  }

  return true;
}

static inline String fmt1(float v) {
  if (isnan(v)) return String("NaN");
  return String(v, 1);
}

void logMeasurementTSV() {
  float t1 = dht.readTemperature();
  float h1 = dht.readHumidity();
  float t2 = dht2.readTemperature();
  float h2 = dht2.readHumidity();

  String iso = isoTimeNow();
  uint64_t ems = epochMsNow();

  String line = iso + "\t" + String((unsigned long long)ems) + "\t"
              + fmt1(t1) + "\t" + fmt1(h1) + "\t"
              + fmt1(t2) + "\t" + fmt1(h2);

  File f = SD.open(LOG_PATH, FILE_APPEND);
  if (!f) {
    Serial.println("Konnte Log-Datei nicht zum Append oeffnen.");
    return;
  }
  f.println(line);
  f.close();

  Serial.println("LOG: " + line);
}

// -------------------- Telegram: Datei per HTTP senden (sendDocument) --------------------
bool telegramSendDocumentFromSD(const String& chat_id, const char* filePath, const char* filename, const char* caption) {
  File f = SD.open(filePath, FILE_READ);
  if (!f) {
    Serial.println("Konnte Datei nicht oeffnen fuer Upload.");
    return false;
  }

  const char* host = "api.telegram.org";
  const int httpsPort = 443;

  WiFiClientSecure https;
  https.setInsecure();

  if (!https.connect(host, httpsPort)) {
    Serial.println("HTTPS connect fehlgeschlagen.");
    f.close();
    return false;
  }

  // Multipart boundary
  const String boundary = "----ESP32Boundary7MA4YWxkTrZu0gW";
  const String CRLF = "\r\n";

  String partChat =
    "--" + boundary + CRLF +
    "Content-Disposition: form-data; name=\"chat_id\"" + CRLF + CRLF +
    chat_id + CRLF;

  String partCaption = "";
  if (caption && String(caption).length() > 0) {
    partCaption =
      "--" + boundary + CRLF +
      "Content-Disposition: form-data; name=\"caption\"" + CRLF + CRLF +
      String(caption) + CRLF;
  }

  String partFileHeader =
    "--" + boundary + CRLF +
    "Content-Disposition: form-data; name=\"document\"; filename=\"" + String(filename) + "\"" + CRLF +
    "Content-Type: text/tab-separated-values" + CRLF + CRLF;

  String closing =
    CRLF + "--" + boundary + "--" + CRLF;

  uint32_t fileSize = f.size();
  uint32_t contentLength = partChat.length() + partCaption.length() + partFileHeader.length() + fileSize + closing.length();

  String url = String("/bot") + BOTtoken + "/sendDocument";

  // HTTP request headers
  https.print(String("POST ") + url + " HTTP/1.1\r\n");
  https.print(String("Host: ") + host + "\r\n");
  https.print("Connection: close\r\n");
  https.print(String("Content-Type: multipart/form-data; boundary=") + boundary + "\r\n");
  https.print(String("Content-Length: ") + contentLength + "\r\n\r\n");

  // Body
  https.print(partChat);
  if (partCaption.length() > 0) https.print(partCaption);
  https.print(partFileHeader);

  // Stream file
  const size_t bufSize = 1024;
  uint8_t buf[bufSize];
  while (f.available()) {
    int n = f.read(buf, bufSize);
    if (n > 0) https.write(buf, n);
  }
  f.close();

  https.print(closing);

  // Read response (basic success check)
  String statusLine = https.readStringUntil('\n');
  statusLine.trim();
  Serial.println("Telegram response: " + statusLine);

  bool ok = statusLine.startsWith("HTTP/1.1 200");

  // Drain remaining (optional debug)
  while (https.connected() || https.available()) {
    https.read();
  }
  https.stop();
  return ok;
}

// -------------------- Lüfter --------------------
void manualFanPulse3s() {
  digitalWrite(FAN_PIN, HIGH);
  fanOn = true;

  unsigned long start = millis();
  while (millis() - start < FAN_ON_DURATION) {
    delay(10);
  }

  digitalWrite(FAN_PIN, LOW);
  fanOn = false;
  lastFanCycle = millis();
}

// -------------------- Status / Uptime --------------------
String formatUptime(unsigned long ms) {
  unsigned long sec = ms / 1000;
  int days = sec / 86400;  sec %= 86400;
  int hours = sec / 3600;  sec %= 3600;
  int mins = sec / 60;     sec %= 60;

  char buffer[64];
  if (days > 0)
    snprintf(buffer, sizeof(buffer), "%dd %02dh %02dm %02ds", days, hours, mins, sec);
  else
    snprintf(buffer, sizeof(buffer), "%02dh %02dm %02ds", hours, mins, sec);

  return String(buffer);
}

void sendStatus() {
  float t1 = dht.readTemperature();
  float h1 = dht.readHumidity();
  float t2 = dht2.readTemperature();
  float h2 = dht2.readHumidity();

  const char* introOptions[] = {
    "*I don't know you, and I don't care to know you!*\n",
    "*Stop right there criminal scum, you violated the law!*\n",
    "*Then pay with your blood!*\n",
    "*Saw a mudcrab the other day. Horrible little creatures.*\n",
    "*You have my ear citizen.*\n",
    "*Nine o'clock on the watch and all's well!*\n"
  };

  const char* outroOptions[] = {
    "\nBye!",
    "\nStop talkin'!",
    "\nStay safe, citizen.",
    "\nMay Talos guide you.",
    "\nBy the Nine Divine!"
  };

  String msg = pickRandom(introOptions, COUNT_OF(introOptions));
  msg += "Time: " + isoTimeNow() + "\n";
  msg += "Temp (DHT1): " + (isnan(t1) ? String("NaN") : String(t1, 1)) + " C\n";
  msg += "Hum  (DHT1): " + (isnan(h1) ? String("NaN") : String(h1, 1)) + " %\n";
  msg += "Temp (DHT2): " + (isnan(t2) ? String("NaN") : String(t2, 1)) + " C\n";
  msg += "Hum  (DHT2): " + (isnan(h2) ? String("NaN") : String(h2, 1)) + " %\n";
  msg += "Up-time: " + formatUptime(millis()) + "\n";
  msg += "Phase: " + String(phase) + ((phase == 1) ? " (Colonisation)" : " (Fruiting)") + "\n";
  msg += "Ventilation: " + String((phase == 2 && fanOn) ? "ON" : "OFF");
  msg += pickRandom(outroOptions, COUNT_OF(outroOptions));

  bot.sendMessage(CHAT_ID, msg, "Markdown");
}

// -------------------- Setup / Loop / Commands --------------------
void setup() {
  Serial.begin(115200);

  dht.begin();
  dht2.begin();

  pinMode(FAN_PIN, OUTPUT);
  digitalWrite(FAN_PIN, LOW);

  randomSeed(millis());

  connectWiFi();
  initTime();

  bool sdOk = initSD();
  if (!sdOk) {
    bot.sendMessage(CHAT_ID, "SD init failed. Check wiring/pins/CS (and SCK!=MOSI).", "");
  } else {
    bot.sendMessage(CHAT_ID, "SD init OK. Logging measurements.tsv every 5 seconds.", "");
  }

  bot.sendMessage(CHAT_ID, "Bot started. Phase: 1 (Colonisation). Fans deactivated.", "");

  lastStatusSend = millis();
  lastLog = millis();
}

void handleCommands(int numNewMessages) {
  for (int i = 0; i < numNewMessages; i++) {
    String chat_id = bot.messages[i].chat_id;
    String text    = bot.messages[i].text;

    if (text == "/phase1") {
      phase = 1;
      fanOn = false;
      digitalWrite(FAN_PIN, LOW);
      bot.sendMessage(chat_id, "Phase set to 1: colonisation. Fans deactivated.", "");
    }
    else if (text == "/phase2") {
      phase = 2;
      fanOn = false;
      digitalWrite(FAN_PIN, LOW);
      bot.sendMessage(chat_id, "Phase set to 2: fruiting. Fans will run 3s / 24h.", "");
      lastFanCycle = millis();
    }
    else if (text == "/fan") {
      bot.sendMessage(chat_id, "Manual ventilation: running fans for 3 seconds.", "");
      manualFanPulse3s();
      bot.sendMessage(chat_id, "Done. Fans are OFF again.", "");
    }
    else if (text == "/status") {
      sendStatus();
    }
    else if (text == "/getlog") {
      if (!SD.exists(LOG_PATH)) {
        bot.sendMessage(chat_id, "Log file not found on SD.", "");
        continue;
      }

      bot.sendMessage(chat_id, "Sending measurements.tsv …", "");

      bool ok = telegramSendDocumentFromSD(chat_id, LOG_PATH, "measurements.tsv", "Incubator log (TSV)");
      if (ok) {
        bot.sendMessage(chat_id, "Sent measurements.tsv", "");
      } else {
        bot.sendMessage(chat_id, "Failed to send file. (Check WiFi / file size / TLS)", "");
      }
    }
    else {
      bot.sendMessage(chat_id,
        "Commands:\n"
        "/status  - view status\n"
        "/getlog  - send measurements.tsv\n"
        "/phase1  - colonisation\n"
        "/phase2  - fruiting\n"
        "/fan     - run fans 3s",
        "");
    }
  }
}

void loop() {
  int numNewMessages = bot.getUpdates(bot.last_message_received + 1);
  if (numNewMessages > 0) {
    handleCommands(numNewMessages);
  }

  // Logging alle 5 Sekunden
  if (millis() - lastLog >= LOG_INTERVAL_MS) {
    logMeasurementTSV();
    lastLog = millis();
  }

  // Status alle 24h (optional)
  if (millis() - lastStatusSend > STATUS_INTERVAL) {
    sendStatus();
    lastStatusSend = millis();
  }

  // Lüfterautomatik nur in Phase 2: 3 Sekunden alle 24h
  if (phase == 2) {
    unsigned long now = millis();
    if (!fanOn && now - lastFanCycle >= FAN_CYCLE_INTERVAL) {
      digitalWrite(FAN_PIN, HIGH);
      fanOn = true;
      lastFanCycle = now;
    }
    else if (fanOn && now - lastFanCycle >= FAN_ON_DURATION) {
      digitalWrite(FAN_PIN, LOW);
      fanOn = false;
      lastFanCycle = now;
    }
  } else {
    digitalWrite(FAN_PIN, LOW);
  }
}
